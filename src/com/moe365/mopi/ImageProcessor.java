package com.moe365.mopi;

import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import com.moe365.mopi.geom.PreciseRectangle;
import com.moe365.mopi.processing.AbstractImageProcessor;
import com.moe365.mopi.processing.DebuggingDiffGenerator;
import com.moe365.mopi.processing.DiffGenerator;

import au.edu.jcu.v4l4j.VideoFrame;

public class ImageProcessor extends AbstractImageProcessor<List<PreciseRectangle>> {
	public static final int DEFAULT_TOLERANCE = 70;
	
	protected final DiffGenerator diff;
	
	/**
	 * Smallest allowed width of a bounding box, in pixels.
	 * 
	 * Decreasing the value of this constant will find smaller blobs,
	 * but will be more computationally expensive.
	 */
	protected final int minBlobWidth;
	
	/**
	 * Smallest allowed height of a bounding box.
	 * @see #minBlobWidth
	 */
	protected final int minBlobHeight;
	
	public ImageProcessor(int frameWidth, int frameHeight, int minBlobWidth, int minBlobHeight, Consumer<List<PreciseRectangle>> handler) {
		this(frameWidth, frameHeight, minBlobWidth, minBlobHeight, handler, false);
	}
	
	public ImageProcessor(int frameWidth, int frameHeight, int minBlobWidth, int minBlobHeight, Consumer<List<PreciseRectangle>> handler, boolean saveDiff) {
		super(0, 0, frameWidth, frameHeight, handler);
		
		if (saveDiff)
			this.diff = new DebuggingDiffGenerator(0, 0, frameWidth, frameHeight, DEFAULT_TOLERANCE);
		else
			this.diff = new DiffGenerator(0, 0, frameWidth, frameHeight, DEFAULT_TOLERANCE);
		
		this.minBlobWidth = minBlobWidth;
		this.minBlobHeight = minBlobHeight;
	}
	
	
	/**
	 * Try to split the image horizontally (perpendicular to the Y axis)
	 * @param img Image
	 * @param xMin Left bound of search area
	 * @param xMax Right bound of search area
	 * @param yMin Bottom of search area
	 * @param yMax Top of search area
	 * @return The index that can be split at, or -1 if no split is found
	 */
	private static final int splitH(boolean[][] img, final int xMin, final int xMax, final int yMin, final int yMax) {
		int step = nextPowerOf2(yMax - yMin);
		while (step > 2) {
			outer: for (int split = yMin + step / 2; split < yMax; split += step) {
				boolean[] row = img[split];
				for (int x = xMin; x < xMax; x++)
					if (row[x])
						continue outer;
				return split;
			}
			step /= 2;
		}
		return -1;
	}
	public boolean[][] calcDeltaAdv(VideoFrame frameOn, VideoFrame frameOff) {
		// Whether the value of any cell in result[][] is valid (has been
		// calculated yet)
		boolean[][] processed = new boolean[getFrameHeight()][getFrameWidth()];
		// boolean array of the results. A cell @ result[y][x] is only
		// valid if processed[y][x] is true.
		boolean[][] result = new boolean[getFrameHeight()][getFrameWidth()];
		System.out.println("Calculating...");
		BufferedImage offImg = frameOff.getBufferedImage();
		BufferedImage onImg = frameOn.getBufferedImage();
		int[] pxOn = new int[3], pxOff = new int[3];
		for (int y = frameMinY + step; y < frameMaxY - step; y += step) {
			final int idxY = y - frameMinY;
			for (int x = frameMinX + step + ((y % (2 * step) == 0) ? step/2 : 0); x < frameMaxX; x += step) {
				final int idxX = x - frameMinX;
				if (processed[idxY][idxX])
					continue;
				processed[idxY][idxX] = true;
				splitRGB(onImg.getRGB(x, y), pxOn);
				splitRGB(offImg.getRGB(x, y), pxOff);
				int dR = pxOn[0] - pxOff[0];
				int dG =  pxOn[1] - pxOff[1];
				int dB =  pxOn[2] - pxOff[2];
				if (dG > tolerance && (dR < dG - 10 || dR < tolerance))//TODO fix
					result[idxY][idxX] = true;
			}
		}
		return result;
	}
	protected List<PreciseRectangle> processBooleanMap(boolean[][] processed) {
		// List of the rectangles to be generated by boundingBoxRecursive
		List<PreciseRectangle> rectangles = new ArrayList<>();
		//find rectangles
		long start = System.nanoTime();
		BoundingBoxThing.boundingBox(processed, rectangles, 0, processed[0].length - 1, 0, processed.length - 1);
		long end = System.nanoTime();
		System.out.println("T: " + (end - start) + "ns");
		//sort the rectangles by area
		final double xFactor = 1.0 / ((double) getFrameWidth());
		final double yFactor = 1.0 / ((double) getFrameHeight());
		//scale the rectangles to be in terms of width/height
		rectangles = rectangles.stream()
				.map(PreciseRectangle.scalar(xFactor, yFactor, xFactor, yFactor))
				.sorted((a, b)->(Double.compare(b.getArea(), a.getArea())))
				.collect(Collectors.toList());
		System.out.println("(done)");
		return rectangles;
	}

	@Override
	public List<PreciseRectangle> apply(VideoFrame frameOn, VideoFrame frameOff) {
		BufferedImage offImg = frameOff.getBufferedImage();
		BufferedImage onImg = frameOn.getBufferedImage();
		//TODO maybe add null check for images
		boolean[][] result = this.diff.apply(onImg, offImg);
		if (result == null)
			return null;
		return processBooleanMap(result);
	}
}
